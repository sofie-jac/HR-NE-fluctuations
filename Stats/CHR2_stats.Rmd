---
title: "CHR2_stats"
author: "SJ"
date: "2024-08-01"
output: pdf_document
---

```{r setup, include=FALSE}
library(pacman)
pacman::p_load(knitr, optimx, MuMIn, tidyverse, emmeans, MASS, boot, robustlmm, dplyr, lmtest, fitdistrplus, car, ggpubr, ggplot2, ggthemes, plyr, lme4, RColorBrewer, reshape2, afex, emmeans, psych, lmerTest, compare, rstatix, ggExtra, gridExtra, ggeffects, modelr, boot, stats)

setwd("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/AUC of Traces")

#set_emm_options(pbkrtest.limit = 5000, lmerTest.limit = 5000)

```


```{r functions, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Function to check assumptions of linear mixed effects model
# Define the data processing function
process_and_combine <- function(df_chr2, df_yfp) {
  # Process chr2_PSD_AUC
  df_chr2 <- df_chr2 %>%
    mutate(Suffix = as.factor(Suffix),
           LaserLevel = as.factor(LaserLevel),
           GT = factor("chr2"))
  
  # Process yfp_PSD_AUC
  df_yfp <- df_yfp %>%
    mutate(Suffix = as.factor(Suffix),
           LaserLevel = as.factor(LaserLevel),
           GT = factor("yfp"))
  
  # Combine the dataframes
  combined_df <- bind_rows(df_chr2, df_yfp)
  
  # Ensure GT is a factor
  combined_df <- combined_df %>%
    mutate(GT = as.factor(GT))
  
  return(combined_df)
}

# Example usage
# Assuming chr2_PSD_AUC and yfp_PSD_AUC are your dataframes
# combined_df <- process_and_combine(chr2_PSD_AUC, yfp_PSD_AUC)
# print(combined_df)

check_lmm_assumptions <- function(model) {
  # Linearity
  print("Checking linearity...")
  plot(model)
  
  # Normality of residuals
  print("Checking normality of residuals...")
  residuals <- resid(model)
  
  # Debugging: Simple histogram of residuals
  hist(residuals, breaks = 30, main = "Histogram of Residuals", xlab = "Residuals", col = "blue", border = "black")
  
  # Create histogram with density fits
  hist_data <- data.frame(residuals = residuals)
  ggplot(hist_data, aes(x = residuals)) +
    geom_histogram(aes(y = ..density..), bins = 30, fill = "blue", alpha = 0.5) +
    stat_function(fun = dnorm, args = list(mean = mean(hist_data$residuals), sd = sd(hist_data$residuals)), color = "red", linewidth = 1) +
    stat_function(fun = function(x) dgamma(x - min(hist_data$residuals) + 0.001, shape = 2, scale = 1), color = "green", linewidth = 1) +
    stat_function(fun = function(x) dweibull(x - min(hist_data$residuals) + 0.001, shape = 2, scale = 1), color = "purple", linewidth = 1) +
    stat_function(fun = function(x) dunif(x, min = min(hist_data$residuals), max = max(hist_data$residuals)), color = "orange", linewidth = 1) +
    ggtitle("Histogram of Residuals with Distribution Fits") +
    theme_minimal()
  
  # Homoscedasticity
  print("Checking homoscedasticity...")
  fitted_values <- fitted(model)
  plot(fitted_values, residuals, main = "Residuals vs Fitted Values")
  abline(h = 0, col = "red")
  
  # Breusch-Pagan Test for homoscedasticity
  bptest_result <- bptest(residuals ~ fitted_values)
  print(bptest_result)
  
  # Independence
  print("Checking independence of residuals...")
  acf(residuals, main = "ACF of residuals")
  
  # Random effects
  print("Checking random effects...")
  ranef_model <- ranef(model, condVar = TRUE)
  qqnorm(unlist(ranef_model$SubjectID))
  qqline(unlist(ranef_model$SubjectID))
  
  print("Assumptions check completed.")
}

perform_bootstrap_pairwise <- function(data, formula, group_var, subject_var, R = 1000) {
  # Fit the initial model
  initial_model <- lmer(formula, data = data)
  
  # Define the bootstrapping function
  boot_model <- function(data, indices) {
    d <- data[indices, ]  # Allows boot to select sample
    model <- try(lmer(formula, data = d, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))), silent = TRUE)
    if (inherits(model, "try-error")) {
      return(rep(NA, choose(length(levels(data[[group_var]])), 2)))  # Return NA if model fails
    } else {
      emm <- emmeans(model, as.formula(paste("~", group_var)))
      contrast <- pairs(emm)
      contrast_summary <- summary(contrast)
      print(contrast_summary)  # Print to verify the order of comparisons
      return(contrast_summary$estimate)  # Return pairwise differences
    }
  }
  
  # Apply bootstrapping with R replications
  results <- boot(data = data, statistic = boot_model, R = R)
  
  # Filter out NA results due to non-converging models
  valid_results <- results$t[!apply(results$t, 1, function(x) any(is.na(x))),]
  
  # Check the number of valid bootstrap samples
  cat("Number of valid bootstrap samples:", nrow(valid_results), "\n")
  
  # Recreate the boot object with only valid results
  boot_results <- results
  boot_results$t <- valid_results
  boot_results$R <- nrow(valid_results)
  
  # Calculate bootstrap confidence intervals for pairwise comparisons
  boot_ci <- function(estimates) {
    apply(estimates, 2, function(col) {
      quantile(col, c(0.025, 0.975))
    })
  }
  
  pairwise_ci <- boot_ci(valid_results)
  
  # Return the bootstrap confidence intervals for pairwise comparisons
  return(pairwise_ci)
}

perform_bootstrap_fixed_effects_correlation <- function(data, formula, subject_var, R = 1000) {
  # Fit the initial model with a specified optimizer
  initial_model <- lmer(formula, data = data, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
  
  # Define the bootstrapping function
  boot_model <- function(data, indices) {
    d <- data[indices, ]  # Allows boot to select sample
    model <- try(lmer(formula, data = d, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))), silent = TRUE)
    if (inherits(model, "try-error")) {
      return(NA)  # Return NA if model fails
    } else {
      cor_matrix <- vcov(model) / (sqrt(diag(vcov(model))) %*% t(sqrt(diag(vcov(model)))))
      cor_fixed_effects <- cor_matrix["(Intercept)", "NE"]
      return(cor_fixed_effects)  # Return the correlation of fixed effects
    }
  }
  
  # Apply bootstrapping with R replications
  results <- boot(data = data, statistic = boot_model, R = R)
  
  # Filter out NA results due to non-converging models
  valid_results <- results$t[!is.na(results$t)]
  
  # Check the number of valid bootstrap samples
  cat("Number of valid bootstrap samples:", length(valid_results), "\n")
  
  # Recreate the boot object with only valid results
  boot_results <- results
  boot_results$t <- valid_results
  boot_results$R <- length(valid_results)
  
  # Calculate bootstrap confidence intervals for the correlation of fixed effects
  boot_ci <- quantile(valid_results, c(0.025, 0.975))
  
  # Return the bootstrap confidence intervals
  return(boot_ci)
}

library(lme4)
library(boot)
library(MuMIn)

perform_bootstrap_fixed_effects_NAs <- function(data, formula, subject_var, R = 1000) {
  # Remove rows with NA values
  data <- na.omit(data)
  
  # Debug: Check data after NA removal
  print(paste("Data rows after NA removal:", nrow(data)))
  
  # Define the bootstrapping function
  boot_model <- function(data, indices) {
    d <- data[indices, ]  # Allows boot to select sample
    
    # Debug: Check the sampled data
    print(paste("Sampled data rows:", nrow(d)))
    
    model <- try(lmer(formula, data = d, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))), silent = TRUE)
    if (inherits(model, "try-error") || isSingular(model)) {
      return(NA)  # Return NA if model fails
    } else {
      cor_matrix <- tryCatch({
        vcov_matrix <- vcov(model)
        cor_matrix <- vcov_matrix / (sqrt(diag(vcov_matrix)) %*% t(sqrt(diag(vcov_matrix))))
        cor_matrix
      }, error = function(e) {
        # Debug: Print error message
        print(paste("Error in calculating correlation matrix:", e$message))
        return(NULL)
      })
      
      if (is.null(cor_matrix)) {
        return(NA)  # Return NA if correlation matrix calculation fails
      }
      
      # Debug: Check the correlation matrix
      print(cor_matrix)
      
      cor_fixed_effects <- tryCatch({
        cor_fixed_effects <- cor_matrix["(Intercept)", "Sigma"]
        cor_fixed_effects
      }, error = function(e) {
        # Debug: Print error message
        print(paste("Error in accessing correlation matrix elements:", e$message))
        return(NA)
      })
      
      return(cor_fixed_effects)  # Return the correlation of fixed effects
    }
  }
  
  # Apply bootstrapping with R replications
  results <- tryCatch({
    boot(data = data, statistic = boot_model, R = R)
  }, error = function(e) {
    # Debug: Print error message
    print(paste("Error in bootstrapping:", e$message))
    return(NULL)
  })
  
  if (is.null(results)) {
    return(NULL)
  }
  
  # Filter out NA results due to non-converging models
  valid_results <- results$t[!is.na(results$t)]
  
  # Check the number of valid bootstrap samples
  cat("Number of valid bootstrap samples:", length(valid_results), "\n")
  
  if (length(valid_results) == 0) {
    return(NULL)
  }
  
  # Recreate the boot object with only valid results
  boot_results <- results
  boot_results$t <- valid_results
  boot_results$R <- length(valid_results)
  
  # Calculate bootstrap confidence intervals for the correlation of fixed effects
  boot_ci <- quantile(valid_results, c(0.025, 0.975))
  
  # Return the bootstrap confidence intervals
  return(boot_ci)
}

library(lme4)
library(boot)

perform_bootstrap_pearson_correlation <- function(data, formula, subject_var, R = 1000) {
  # Remove rows with NA values
  data <- na.omit(data)
  
  # Define the bootstrapping function
  boot_model <- function(data, indices) {
    d <- data[indices, ]  # Allows boot to select sample
    
    model <- try(lmer(formula, data = d, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))), silent = TRUE)
    if (inherits(model, "try-error") || isSingular(model)) {
      return(NA)  # Return NA if model fails
    } else {
      fitted_values <- fitted(model)
      observed_values <- d$RR  # Assuming RR is the response variable
      if (length(fitted_values) != length(observed_values)) {
        return(NA)  # Return NA if lengths do not match
      }
      correlation <- cor(observed_values, fitted_values)
      return(correlation)  # Return the Pearson correlation coefficient
    }
  }
  
  # Apply bootstrapping with R replications
  results <- tryCatch({
    boot(data = data, statistic = boot_model, R = R)
  }, error = function(e) {
    # Debug: Print error message
    print(paste("Error in bootstrapping:", e$message))
    return(NULL)
  })
  
  if (is.null(results)) {
    return(NULL)
  }
  
  # Filter out NA results due to non-converging models
  valid_results <- results$t[!is.na(results$t)]
  
  # Check the number of valid bootstrap samples
  cat("Number of valid bootstrap samples:", length(valid_results), "\n")
  
  if (length(valid_results) == 0) {
    return(NULL)
  }
  
  # Recreate the boot object with only valid results
  boot_results <- results
  boot_results$t <- valid_results
  boot_results$R <- length(valid_results)
  
  # Calculate bootstrap confidence intervals for the Pearson correlation coefficient
  boot_ci <- quantile(valid_results, c(0.025, 0.975))
  
  # Return the bootstrap confidence intervals
  return(boot_ci)
}


pearson <- function(model, y) { 
  # Extract fitted values from the model
fitted_values <- fitted(model)

# Get the indices of the non-NA values used in the model
used_indices <- as.numeric(names(fitted_values))

# Extract the corresponding observed values
observed_values <- y[used_indices]

# Calculate Pearson correlation between observed and fitted values
correlation <- cor(observed_values, fitted_values)
print(correlation)
}

reshape_and_combine <- function(df_chr2, df_yfp) {
  library(dplyr)
  library(tidyr)
  
  process_dataframe <- function(df, gt_value) {
    # Identify columns with 'LaserLevel_' in the name
    laser_cols <- grep("LaserLevel_", colnames(df), value = TRUE)
    
    # Rename columns by removing anything prior to 'LaserLevel'
    new_names <- gsub("^.*?(LaserLevel_\\d+)$", "\\1", laser_cols)
    colnames(df)[match(laser_cols, colnames(df))] <- new_names
    
    # Convert to long format and handle NaNs
    df_long <- df %>%
      pivot_longer(cols = starts_with("LaserLevel_"), 
                   names_to = "LaserLevel", 
                   values_to = "data") %>%
      filter(!is.na(data)) %>%
      mutate(data = as.numeric(data), 
             LaserLevel = as.factor(LaserLevel))
    
    # Convert 'SubjectID' to factor if it exists
    if ("SubjectID" %in% colnames(df_long)) {
      df_long <- df_long %>%
        mutate(SubjectID = as.factor(SubjectID))
    }
    
    # Add 'GT' column
    df_long <- df_long %>%
      mutate(GT = as.factor(gt_value))
    
    return(df_long)
  }
  
  # Process each dataframe
  df_chr2_long <- process_dataframe(df_chr2, "chr2")
  df_yfp_long <- process_dataframe(df_yfp, "yfp")
  
  # Combine the dataframes
  combined_df <- bind_rows(df_chr2_long, df_yfp_long) %>%
    select(SubjectID, GT, data, LaserLevel)
  
  return(combined_df)
}

# Example usage
# combined_df <- reshape_and_combine(NE_AUC_pre_chr2, NE_AUC_pre_yfp)
  preprocess_dataframe <- function(df) {
    # Identify columns with 'LaserLevel_' in the name
    laser_cols <- grep("LaserLevel_", colnames(df), value = TRUE)
    
    # Rename columns by removing anything prior to 'LaserLevel'
    new_names <- gsub("^.*?(LaserLevel_\\d+)$", "\\1", laser_cols)
    colnames(df)[match(laser_cols, colnames(df))] <- new_names
    
    # Convert to long format and handle NaNs
    df_long <- df %>%
      pivot_longer(cols = starts_with("LaserLevel_"), 
                   names_to = "LaserLevel", 
                   values_to = "data") %>%
      filter(!is.na(data)) %>%
      mutate(data = as.numeric(data), 
             LaserLevel = as.factor(LaserLevel))
    
    # Convert 'SubjectID' to factor if it exists
    if ("SubjectID" %in% colnames(df_long)) {
      df_long <- df_long %>%
        mutate(SubjectID = as.factor(SubjectID))
    }
    
    return(df_long)
  }
  
  
  library(lme4)
library(emmeans)
library(boot)

library(lme4)
library(emmeans)
library(boot)

bootstrap_pairwise_contrasts <- function(data, formula, group_var, subject_var, R = 1000) {
  # Fit the initial model
  initial_model <- lmer(formula, data = data, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
  
  # Define the bootstrapping function
  boot_model <- function(data, indices) {
    d <- data[indices, ]  # Allows boot to select sample
    model <- try(lmer(formula, data = d, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))), silent = TRUE)
    if (inherits(model, "try-error")) {
      return(rep(NA, 2 * length(levels(d[[group_var]])) - 2))  # Return NA if model fails
    } else {
      emm <- emmeans(model, as.formula(paste("~", group_var)))
      
      # Perform pairwise comparisons within each GT for all LaserLevels
      contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "GT")
      
      # Perform pairwise comparisons between the two levels of GT for each LaserLevel
      contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel")
      
      # Combine the results
      contrast_summary_within_GT <- summary(contrast_within_GT)
      contrast_summary_between_GT <- summary(contrast_between_GT)
      
      # Combine estimates from both comparisons
      combined_estimates <- c(contrast_summary_within_GT$estimate, contrast_summary_between_GT$estimate)
      
      # Print the first successful iteration's results
      if (!exists("printed_first")) {
        print(combined_estimates)
        assign("printed_first", TRUE, envir = .GlobalEnv)
      }
      
      return(combined_estimates)
    }
  }
  
  # Counter to track the number of iterations
  counter <- 0
  
  # Wrapper function to increment the counter
  boot_model_wrapper <- function(data, indices) {
    counter <<- counter + 1
    cat("Iteration:", counter, "\n")
    boot_model(data, indices)
  }
  
  # Apply bootstrapping with R replications
  results <- boot(data = data, statistic = boot_model_wrapper, R = R)
  
  # Filter out NA results due to non-converging models
  valid_results <- results$t[!apply(results$t, 1, function(x) any(is.na(x))),]
  
  # Check the number of valid bootstrap samples
  cat("Number of valid bootstrap samples:", nrow(valid_results), "\n")
  
  # Recreate the boot object with only valid results
  boot_results <- results
  boot_results$t <- valid_results
  boot_results$R <- nrow(valid_results)
  
  # Calculate bootstrap confidence intervals for pairwise comparisons
  boot_ci <- function(estimates) {
    apply(estimates, 2, function(col) {
      quantile(col, c(0.025, 0.975))
    })
  }
  
  pairwise_ci <- boot_ci(valid_results)
  
  # Remove the printed_first variable from the global environment
  if (exists("printed_first", envir = .GlobalEnv)) {
    rm("printed_first", envir = .GlobalEnv)
  }
  
  # Return the bootstrap confidence intervals for pairwise comparisons
  return(pairwise_ci)
}

# Example usage
# pairwise_ci <- bootstrap_pairwise_contrasts(NE_AUC_pre, data ~ LaserLevel * GT + (1|SubjectID), "LaserLevel * GT", "SubjectID", R = 1000)
# print(pairwise_ci)

# Define the block bootstrapping function
bootstrap_block_pairwise_contrasts <- function(data, formula, group_var, subject_var, R = 1000) {
  # Check if 'BoutLength' column exists in data
  use_weights <- 'BoutLength' %in% names(data)
  
  # Fit the initial model with or without weights
  if (use_weights) {
    initial_model <- lmer(
      formula,
      data = data,
      weights = BoutLength,
      control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))
    )
  } else {
    initial_model <- lmer(
      formula,
      data = data,
      control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))
    )
  }
  
  # Check the number of estimates to be returned
  emm <- emmeans(initial_model, ~ LaserLevel * group)
  contrast_within_laser <- contrast(emm, interaction = "pairwise", by = "LaserLevel")
  contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "group")
  n_estimates <- length(c(summary(contrast_within_laser)$estimate, summary(contrast_within_GT)$estimate))
  
  # Define the bootstrapping function
  boot_model <- function(data, indices) {
    unique_subjects <- unique(data[[subject_var]])
    sampled_subjects <- unique_subjects[indices]
    d <- data[data[[subject_var]] %in% sampled_subjects, ]
    
    # Fit the model with or without weights
    if (use_weights) {
      model <- try(
        lmer(
          formula,
          data = d,
          weights = BoutLength,
          control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))
        ),
        silent = TRUE
      )
    } else {
      model <- try(
        lmer(
          formula,
          data = d,
          control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))
        ),
        silent = TRUE
      )
    }
    
    if (inherits(model, "try-error")) {
      return(rep(NA, n_estimates))  # Return NA if model fails
    } else {
      emm <- try(emmeans(model, ~ LaserLevel * group), silent = TRUE)
      if (inherits(emm, "try-error")) {
        return(rep(NA, n_estimates))  # Return NA if emmeans fails
      }
      
      # Perform pairwise comparisons within LaserLevel for each group
      contrast_within_laser <- try(contrast(emm, interaction = "pairwise", by = "LaserLevel"), silent = TRUE)
      if (inherits(contrast_within_laser, "try-error")) {
        return(rep(NA, n_estimates))  # Return NA if contrast fails
      }
      
      # Perform pairwise comparisons within group for each LaserLevel
      contrast_within_GT <- try(contrast(emm, interaction = "pairwise", by = "group"), silent = TRUE)
      if (inherits(contrast_within_GT, "try-error")) {
        return(rep(NA, n_estimates))  # Return NA if contrast fails
      }
      
      contrast_summary_within_laser <- summary(contrast_within_laser)
      contrast_summary_within_GT <- summary(contrast_within_GT)
      
      # Combine estimates from both comparisons
      combined_estimates <- c(
        contrast_summary_within_laser$estimate,
        contrast_summary_within_GT$estimate
      )
      
      # Ensure the length of combined_estimates matches n_estimates
      if (length(combined_estimates) != n_estimates) {
        return(rep(NA, n_estimates))
      }
      
      # Print the first successful iteration's results
      if (!exists("printed_first", envir = .GlobalEnv)) {
        print(combined_estimates)
        assign("printed_first", TRUE, envir = .GlobalEnv)
      }
      
      return(combined_estimates)
    }
  }
  
  # Counter to track the number of iterations
  counter <- 0
  
  # Wrapper function to increment the counter
  boot_model_wrapper <- function(data, indices) {
    counter <<- counter + 1
    cat("Iteration:", counter, "\n")
    boot_model(data, indices)
  }
  
  # Apply block bootstrapping with R replications
  set.seed(123)
  subject_indices <- 1:length(unique(data[[subject_var]]))
  results <- tryCatch({
    boot(
      data = data,
      statistic = boot_model_wrapper,
      R = R,
      strata = data[[subject_var]],
      sim = "ordinary"
    )
  }, error = function(e) {
    cat("Bootstrap error: ", e$message, "\n")
    return(NULL)
  })
  
  if (is.null(results)) {
    stop("Bootstrap process failed.")
  }
  
  # Filter out NA results due to non-converging models
  valid_results <- results$t[!apply(results$t, 1, function(x) any(is.na(x))), ]
  
  # Check the number of valid bootstrap samples
  cat("Number of valid bootstrap samples:", nrow(valid_results), "\n")
  
  if (nrow(valid_results) == 0) {
    stop("No valid bootstrap samples were obtained.")
  }
  
  # Recreate the boot object with only valid results
  boot_results <- results
  boot_results$t <- valid_results
  boot_results$R <- nrow(valid_results)
  
  # Calculate bootstrap confidence intervals for pairwise comparisons
  boot_ci <- function(estimates) {
    apply(estimates, 2, function(col) {
      quantile(col, c(0.025, 0.975))
    })
  }
  
  pairwise_ci <- boot_ci(valid_results)
  
  # Remove the printed_first variable from the global environment
  if (exists("printed_first", envir = .GlobalEnv)) {
    rm("printed_first", envir = .GlobalEnv)
  }
  
  # Return the bootstrap confidence intervals for pairwise comparisons
  return(pairwise_ci)
}



bootstrap_block_pairwise_laser <- function(data, formula, subject_var, R = 1000) {
  # 1. Fit the initial mixed model (no weights)
  initial_model <- lmer(
    formula,
    data    = data,
    control = lmerControl(optimizer = "bobyqa",
                          optCtrl   = list(maxfun = 1e5))
  )
  
  # 2. Compute the number of pairwise LaserLevel contrasts
  emm0        <- emmeans(initial_model, ~ LaserLevel)
  c0          <- contrast(emm0, method = "pairwise")
  n_estimates <- length(summary(c0)$estimate)
  
  # 3. Define a single‐subject block bootstrap statistic
  boot_model <- function(dat, inds) {
    # resample subjects with replacement
    subs           <- unique(dat[[subject_var]])
    sampled_subs   <- subs[inds]
    d              <- dat[dat[[subject_var]] %in% sampled_subs, , drop = FALSE]
    
    # refit model
    m <- try(
      lmer(formula, data = d,
           control = lmerControl(optimizer = "bobyqa",
                                 optCtrl   = list(maxfun = 1e5))),
      silent = TRUE
    )
    if (inherits(m, "try-error")) {
      return(rep(NA_real_, n_estimates))
    }
    
    # re‐estimate emmeans & contrasts
    emm_b <- try(emmeans(m, ~ LaserLevel), silent = TRUE)
    if (inherits(emm_b, "try-error")) {
      return(rep(NA_real_, n_estimates))
    }
    c_b <- try(contrast(emm_b, method = "pairwise"), silent = TRUE)
    if (inherits(c_b, "try-error")) {
      return(rep(NA_real_, n_estimates))
    }
    
    est <- summary(c_b)$estimate
    if (length(est) != n_estimates) {
      return(rep(NA_real_, n_estimates))
    }
    est
  }
  
  # 4. Run the bootstrap
  set.seed(123)
  subj_inds <- seq_along(unique(data[[subject_var]]))
  bs <- boot(
    data      = data,
    statistic = boot_model,
    R         = R,
    strata    = data[[subject_var]],
    sim       = "ordinary"
  )
  
  # 5. Drop any failed (NA) replicates
  good <- !apply(bs$t, 1, function(x) any(is.na(x)))
  t0   <- bs$t[good, , drop = FALSE]
  if (nrow(t0) == 0) {
    stop("No valid bootstrap samples were obtained.")
  }
  
  # 6. Compute 95% CIs
  ci <- apply(t0, 2, quantile, probs = c(0.025, 0.975))
  return(ci)
}

```

RR peak power

```{r}
RR_peakPower_2min <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/combined_RR_peakPower_psd.csv")
RR_peakPower <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/PSD_round_2/combined_RR_peakPower_psd.csv")
RR_peakPower <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/PSD_round_3/RR_psd_peak.csv")
RR_peakPower <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/PSD_round_3/w. bout duration/RR_psd_peak.csv")

  RR_peakPower <- RR_peakPower %>%
    mutate(Suffix = as.factor(Suffix),
           LaserLevel = as.factor(LaserLevel),
           group = as.factor(group))

m1_RR_peakPower <- lmer(formula = PeakPower ~  LaserLevel * group + (1|Suffix), data = RR_peakPower, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)), , weights = BoutLength)
m3_RR_peakPower <- lmer(formula = PeakPower ~  LaserLevel * group + (LaserLevel|Suffix), data = RR_peakPower, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m2_RR_peakPower <- lmer(formula = PeakPower ~  LaserLevel + group + (1|Suffix), data = RR_peakPower)

anova(m1_RR_peakPower, m2_RR_peakPower) # M1

check_lmm_assumptions(m1_RR_peakPower) #problems with everything

# Calculate estimated marginal means
emm <- emmeans(m1_RR_peakPower, ~ LaserLevel * group, pbkrtest.limit = 3737, lmerTest.limit = 3737)

# Perform pairwise comparisons within each group for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "group", adjust = "tukey")
# Perform pairwise comparisons between the two levels of GT for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons_RR_peakPower <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci_RR_peakPower <- bootstrap_block_pairwise_contrasts(RR_peakPower, PeakPower ~ LaserLevel * group + (1 | Suffix), "group", "Suffix", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci_RR_peakPower)
print(pairwise_comparisons_RR_peakPower)
print(summary(m1_RR_peakPower))
```

NE peak power

```{r}
NE_peakPower <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/combined_NE_peakPower_psd.csv")

NE_peakPower <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/PSD_round_2/combined_NE_peakPower_psd.csv")

  NE_peakPower <- NE_peakPower %>%
    mutate(Suffix = as.factor(Suffix),
           LaserLevel = as.factor(LaserLevel),
           GT = as.factor(GT))

m1_NE_peakPower <- lmer(formula = PeakPower ~  LaserLevel * GT + (1|Suffix), data = NE_peakPower, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m3_NE_peakPower <- lmer(formula = PeakPower ~  LaserLevel * GT + (LaserLevel|Suffix), data = NE_peakPower, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m2_NE_peakPower <- lmer(formula = PeakPower ~  LaserLevel + GT + (1|Suffix), data = NE_peakPower)

anova(m1_NE_peakPower, m2_NE_peakPower) # M1

check_lmm_assumptions(m1_NE_peakPower) #problems with everything

# Calculate estimated marginal means
emm <- emmeans(m1_NE_peakPower, ~ LaserLevel * GT, pbkrtest.limit = 3737, lmerTest.limit = 3737)

# Perform pairwise comparisons within each GT for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "GT", adjust = "tukey")
# Perform pairwise comparisons between the two levels of GT for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons_NE_peakPower <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci_NE_peakPower <- bootstrap_block_pairwise_contrasts(NE_peakPower, PeakPower ~ LaserLevel * GT + (1 | Suffix), "GT", "Suffix", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci_NE_peakPower)
print(pairwise_comparisons_NE_peakPower)
print(summary(m1_NE_peakPower))  
```

RR peak freq

```{r}
RR_peakfreq <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/combined_RR_peakfreq_psd.csv")
RR_peakfreq <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/PSD_round_2/combined_RR_peakfreq_psd.csv")
RR_peakfreq <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/PSD_round_3/RR_psd_freq.csv")
RR_peakfreq <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/PSD_round_3/w. bout duration/RR_psd_freq.csv")

  RR_peakfreq <- RR_peakfreq %>%
    mutate(Suffix = as.factor(Suffix),
           LaserLevel = as.factor(LaserLevel),
           group = as.factor(group))

m1_RR_peakfreq <- lmer(formula = PeakFrequency ~  LaserLevel * group + (1|Suffix), data = RR_peakfreq, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)), weights = BoutLength)
m3_RR_peakfreq <- lmer(formula = PeakFrequency ~  LaserLevel * group + (LaserLevel|Suffix), data = RR_peakfreq, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m2_RR_peakfreq <- lmer(formula = PeakFrequency ~  LaserLevel + group + (1|Suffix), data = RR_peakfreq)

anova(m1_RR_peakfreq, m2_RR_peakfreq) # M1

check_lmm_assumptions(m1_RR_peakfreq) #problems with everything except herterosca

# Calculate estimated marginal means
emm <- emmeans(m1_RR_peakfreq, ~ LaserLevel * group, pbkrtest.limit = 3737, lmerTest.limit = 3737)

# Perform pairwise comparisons within each group for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "group", adjust = "tukey")
# Perform pairwise comparisons between the two levels of group for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons_RR_peakfreq <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci_RR_peakfreq <- bootstrap_block_pairwise_contrasts(RR_peakfreq, PeakFrequency ~ LaserLevel * group + (1 | Suffix), "GT", "Suffix", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci_RR_peakfreq)
print(pairwise_comparisons_RR_peakfreq)
print(summary(m1_RR_peakfreq))  
```

NE peak freq

```{r}
NE_peakfreq <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/combined_NE_peakfreq_psd.csv")
NE_peakfreq <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/PSD_round_2/combined_NE_peakfreq_psd.csv")

  NE_peakfreq <- NE_peakfreq %>%
    mutate(Suffix = as.factor(Suffix),
           LaserLevel = as.factor(LaserLevel),
           GT = as.factor(GT))

m1_NE_peakfreq <- lmer(formula = PeakFrequency ~  LaserLevel * GT + (1|Suffix), data = NE_peakfreq, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m3_NE_peakfreq <- lmer(formula = PeakFrequency ~  LaserLevel * GT + (LaserLevel|Suffix), data = NE_peakfreq, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m2_NE_peakfreq <- lmer(formula = PeakFrequency ~  LaserLevel + GT + (1|Suffix), data = NE_peakfreq)

anova(m1_NE_peakfreq, m2_NE_peakfreq) # M1

check_lmm_assumptions(m1_NE_peakfreq) #problems with everything

# Calculate estimated marginal means
emm <- emmeans(m1_NE_peakfreq, ~ LaserLevel * GT, pbkrtest.limit = 3737, lmerTest.limit = 3737)

# Perform pairwise comparisons within each GT for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "GT", adjust = "tukey")
# Perform pairwise comparisons between the two levels of GT for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons_NE_peakfreq <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci_NE_peakfreq <- bootstrap_block_pairwise_contrasts(NE_peakfreq, PeakFrequency ~ LaserLevel * GT + (1 | Suffix), "GT", "Suffix", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci_NE_peakfreq)
print(pairwise_comparisons_NE_peakfreq)
print(summary(m1_NE_peakfreq))  
```



RR PSD AUC

```{r}
PSD_AUC_RR <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/PSD_round_2/combined_RR_AUC_psd.csv")
PSD_AUC_RR <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/PSD_round_3/RR_psd_AUC.csv")
PSD_AUC_RR <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/PSD_round_3/w. bout duration/RR_psd_AUC.csv")

  PSD_AUC_RR <- PSD_AUC_RR %>%
    mutate(Suffix = as.factor(Suffix),
           LaserLevel = as.factor(LaserLevel),
           group = as.factor(group))

m1_RR_PSD_AUC <- lmer(formula = AUC ~  LaserLevel * group + (1|Suffix), data = PSD_AUC_RR, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)), weights = BoutLength)
m3_RR_PSD_AUC <- lmer(formula = AUC ~  LaserLevel * group + (LaserLevel|Suffix), data = PSD_AUC_RR, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)), weights = BoutLength)
m2_RR_PSD_AUC <- lmer(formula = AUC ~  LaserLevel + group + (1|Suffix), data = PSD_AUC_RR, weights = BoutLength)

anova(m1_RR_PSD_AUC, m2_RR_PSD_AUC) # M1

check_lmm_assumptions(m1_RR_PSD_AUC) #problems with everything

# Calculate estimated marginal means
emm <- emmeans(m1_RR_PSD_AUC, ~ LaserLevel * group, pbkrtest.limit = 3737, lmerTest.limit = 3737)

# Perform pairwise comparisons within each group for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "group", adjust = "tukey")
# Perform pairwise comparisons between the two levels of group for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons_RR_PSD_AUC <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci_RR_PSD_AUC <- bootstrap_block_pairwise_contrasts(PSD_AUC_RR, AUC ~ LaserLevel * group + (1 | Suffix), "group", "Suffix", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci_RR_PSD_AUC)
print(pairwise_comparisons_RR_PSD_AUC)
print(summary(m1_RR_PSD_AUC))
```



NE PSD AUC

```{r}

yfp_PSD_AUC  <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/yfp_PSD_AUC_NE_RR_combined_table.csv")
chr2_PSD_AUC <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/chr2_AUC_NE_RR_combined_table.csv")

PSD_AUC <- process_and_combine(chr2_PSD_AUC, yfp_PSD_AUC)

PSD_AUC_NE <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/PSD_round_2/combined_NE_AUC_psd.csv")

  PSD_AUC_NE <- PSD_AUC_NE %>%
    mutate(Suffix = as.factor(Suffix),
           LaserLevel = as.factor(LaserLevel),
           GT = as.factor(GT))


m1_NE_PSD_AUC <- lmer(formula = AUC ~  LaserLevel * GT + (1|Suffix), data = PSD_AUC_NE, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m3_NE_PSD_AUC <- lmer(formula = AUC ~  LaserLevel * GT + (LaserLevel|Suffix), data = PSD_AUC_NE, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m2_NE_PSD_AUC <- lmer(formula = AUC ~  LaserLevel + GT + (1|Suffix), data = PSD_AUC_NE)

anova(m1_NE_PSD_AUC, m2_NE_PSD_AUC) # M1

check_lmm_assumptions(m1_NE_PSD_AUC) #problems with everything

# Calculate estimated marginal means
emm <- emmeans(m1_NE_PSD_AUC, ~ LaserLevel * GT, pbkrtest.limit = 3737, lmerTest.limit = 3737)

# Perform pairwise comparisons within each GT for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "GT", adjust = "tukey")
# Perform pairwise comparisons between the two levels of GT for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons_NE_PSD_AUC <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci_NE_PSD_AUC <- bootstrap_block_pairwise_contrasts(PSD_AUC_NE, AUC ~ LaserLevel * GT + (1 | Suffix), "GT", "Suffix", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci_NE_PSD_AUC)
print(pairwise_comparisons_NE_PSD_AUC)
print(summary(m1_NE_PSD_AUC))
```








RR AUC prepost
```{r}
RR_AUC_prepost_chr2 <- read_csv('C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/AUC of Traces/RR_combined_both_table.csv')
RR_AUC_prepost_yfp <-read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/AUC of Traces/RR_combined_both_table.csv")
RR_AUC_prepost <- reshape_and_combine(RR_AUC_prepost_chr2, RR_AUC_prepost_yfp)


m1_RR_AUC_prepost <- lmer(formula = data ~  LaserLevel * GT + (1|SubjectID), data = RR_AUC_prepost, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m2_RR_AUC_prepost <- lmer(formula = data ~  LaserLevel + GT + (1|SubjectID), data = RR_AUC_prepost)

anova(m1_RR_AUC_prepost, m2_RR_AUC_prepost) # M1

check_lmm_assumptions(m1_RR_AUC_prepost)


# Calculate estimated marginal means
emm <- emmeans(m1_RR_AUC_prepost, ~ LaserLevel * GT, pbkrtest.limit = 3737, lmerTest.limit = 3737)

# Perform pairwise comparisons within each GT for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "GT", adjust = "tukey")
# Perform pairwise comparisons between the two levels of GT for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci_RR_AUC_prepost <- bootstrap_pairwise_contrasts(RR_AUC_prepost, data ~ LaserLevel * GT + (1|SubjectID), "LaserLevel * GT", "SubjectID", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci_RR_AUC_prepost)
print(pairwise_comparisons)
print(summary(m1_RR_AUC_prepost))
```


RR AUC post
```{r}
RR_AUC_post_chr2 <- read_csv('C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/AUC of Traces/RR_combined_post_table.csv')
RR_AUC_post_yfp <-read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/AUC of Traces/RR_combined_post_yfp.csv")
RR_AUC_post <- reshape_and_combine(RR_AUC_post_chr2, RR_AUC_post_yfp)


m1_RR_AUC_post <- lmer(formula = data ~  LaserLevel * GT + (1|SubjectID), data = RR_AUC_post, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m2_RR_AUC_post <- lmer(formula = data ~  LaserLevel + GT + (1|SubjectID), data = RR_AUC_post)

anova(m1_RR_AUC_post, m2_RR_AUC_post) # M1

check_lmm_assumptions(m1_RR_AUC_post)


# Calculate estimated marginal means
emm <- emmeans(m1_RR_AUC_post, ~ LaserLevel * GT, pbkrtest.limit = 3737, lmerTest.limit = 3737)

# Perform pairwise comparisons within each GT for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "GT", adjust = "tukey")
# Perform pairwise comparisons between the two levels of GT for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci_RR_AUC_post <- bootstrap_pairwise_contrasts(RR_AUC_post, data ~ LaserLevel * GT + (1|SubjectID), "LaserLevel * GT", "SubjectID", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci_RR_AUC_post)
print(pairwise_comparisons)
print(summary(m1_RR_AUC_post))
```

RR AUC Pre
```{r}
RR_AUC_pre_chr2 <- read_csv('C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/AUC of Traces/RR_combined_pre_table.csv')
RR_AUC_pre_yfp <-read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/AUC of Traces/RR_combined_pre_yfp.csv")
RR_AUC_pre <- reshape_and_combine(RR_AUC_pre_chr2, RR_AUC_pre_yfp)


m1_RR_AUC_pre <- lmer(formula = data ~  LaserLevel * GT + (1|SubjectID), data = RR_AUC_pre, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m2_RR_AUC_pre <- lmer(formula = data ~  LaserLevel + GT + (1|SubjectID), data = RR_AUC_pre)

anova(m1_RR_AUC_pre, m2_RR_AUC_pre) # M1

check_lmm_assumptions(m1_RR_AUC_pre)

# Calculate estimated marginal means
emm <- emmeans(m1_RR_AUC_pre, ~ LaserLevel * GT, pbkrtest.limit = 3737, lmerTest.limit = 3737)

# Perform pairwise comparisons within each GT for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "GT", adjust = "tukey")
# Perform pairwise comparisons between the two levels of GT for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci_RR_AUC_pre <- bootstrap_pairwise_contrasts(RR_AUC_pre, data ~ LaserLevel * GT + (1|SubjectID), "LaserLevel * GT", "SubjectID", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci_RR_AUC_pre)
print(pairwise_comparisons)
print(summary(m1_RR_AUC_pre))
```

NE AUC pre-post

```{r}
NE_AUC_prepost_chr2 <- read_csv('C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/AUC of Traces/NE_combined_both_table.csv')
NE_AUC_prepost_yfp <-read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/AUC of Traces/NE_combined_both_table.csv")
NE_AUC_prepost <- reshape_and_combine(NE_AUC_prepost_chr2, NE_AUC_prepost_yfp)

m1_NE_AUC_prepost <- lmer(formula = data ~  LaserLevel * GT + (1|SubjectID), data = NE_AUC_prepost, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m2_NE_AUC_prepost <- lmer(formula = data ~  LaserLevel + GT + (1|SubjectID), data = NE_AUC_prepost)

anova(m1_NE_AUC_prepost, m2_NE_AUC_prepost) # M1

check_lmm_assumptions(m1_NE_AUC_prepost)


# Calculate estimated marginal means
emm <- emmeans(m1_NE_AUC_prepost, ~ LaserLevel * GT, pbkrtest.limit = 3737, lmerTest.limit = 3737)


# Perform pairwise comparisons within each GT for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "GT", adjust = "tukey")
# Perform pairwise comparisons between the two levels of GT for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci_NE_AUC_prepost <- bootstrap_pairwise_contrasts(NE_AUC_prepost, data ~ LaserLevel * GT + (1|SubjectID), "LaserLevel * GT", "SubjectID", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci_NE_AUC_prepost)
print(pairwise_comparisons)
print(summary(m1_NE_AUC_prepost))
```



NE AUC post

```{r}
NE_AUC_post_chr2 <- read_csv('C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/AUC of Traces/NE_combined_post_table.csv')
NE_AUC_post_yfp <-read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/AUC of Traces/NE_combined_post_yfp.csv")
NE_AUC_post <- reshape_and_combine(NE_AUC_post_chr2, NE_AUC_post_yfp)

m1_NE_AUC_post <- lmer(formula = data ~  LaserLevel * GT + (1|SubjectID), data = NE_AUC_post, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m2_NE_AUC_post <- lmer(formula = data ~  LaserLevel + GT + (1|SubjectID), data = NE_AUC_post)

anova(m1_NE_AUC_post, m2_NE_AUC_post) # M1

check_lmm_assumptions(m1_NE_AUC_post)


# Calculate estimated marginal means
emm <- emmeans(m1_NE_AUC_post, ~ LaserLevel * GT, pbkrtest.limit = 3737, lmerTest.limit = 3737)

# Perform pairwise comparisons within each GT for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "GT", adjust = "tukey")
# Perform pairwise comparisons between the two levels of GT for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci_NE_AUC_post <- bootstrap_pairwise_contrasts(NE_AUC_post, data ~ LaserLevel * GT + (1|SubjectID), "LaserLevel * GT", "SubjectID", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci_NE_AUC_post)
print(pairwise_comparisons)
print(summary(m1_NE_AUC_post))

```

NE AUC pre

```{r pressure, echo=FALSE}
NE_AUC_pre_chr2 <- read_csv('C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/AUC of Traces/NE_combined_pre_table.csv')
NE_AUC_pre_yfp <-read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/AUC of Traces/NE_combined_pre_yfp.csv")
NE_AUC_pre <- reshape_and_combine(NE_AUC_pre_chr2, NE_AUC_pre_yfp)

NE_AUC_pre_chr2 <- preprocess_dataframe(NE_AUC_pre_chr2)
NE_AUC_pre_yfp <- preprocess_dataframe(NE_AUC_pre_yfp)

#all-in-one models
m_h1 <- lmer(formula = data ~  LaserLevel + GT + (1|SubjectID), data = NE_AUC_pre)
m_h2 <- lmer(formula = data ~  LaserLevel + GT + (LaserLevel|SubjectID), data = NE_AUC_pre, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m_h3 <- lmer(formula = data ~  LaserLevel + (LaserLevel|SubjectID), data = NE_AUC_pre, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m_h4 <- lmer(formula = data ~  LaserLevel * GT + (LaserLevel|SubjectID), data = NE_AUC_pre, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m_h5 <- lmer(formula = data ~  LaserLevel * GT + (1|SubjectID), data = NE_AUC_pre, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))

anova(m_h4, m_h5) # M4 is better but singular

check_lmm_assumptions(m_h5)


pairwise_ci <- perform_bootstrap_pairwise(NE_AUC_pre, data ~  LaserLevel * GT + (1|SubjectID), "LaserLevel * GT", "SubjectID", R = 1000)
print(pairwise_ci)

# Calculate estimated marginal means
emm <- emmeans(m_h5, ~ LaserLevel * GT, pbkrtest.limit = 3737, lmerTest.limit = 3737)

# Perform pairwise comparisons within each GT for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "GT", adjust = "tukey")
# Perform pairwise comparisons between the two levels of GT for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci <- bootstrap_pairwise_contrasts(NE_AUC_pre, data ~ LaserLevel * GT + (1|SubjectID), "LaserLevel * GT", "SubjectID", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci)
print(pairwise_comparisons)
print(summary(m_h5))





#Broken up models
m_h1_chr2 <- lmer(formula = data ~  LaserLevel + (1|SubjectID), data = NE_AUC_pre_chr2)
m_h2_chr2 <- lmer(formula = data ~  LaserLevel + (LaserLevel|SubjectID), data = NE_AUC_pre_chr2, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))

anova(m_h1_chr2, m_h2_chr2) # m_h2_chr2 is better but we use m_h1_chr2 as it needs to be comparable to yfp model

# Example usage with your model
check_lmm_assumptions(m_h1_chr2)

# Calculate estimated marginal means
emm <- emmeans(m_h1_chr2, ~ LaserLevel, pbkrtest.limit = 3737, lmerTest.limit = 3737)

# Perform pairwise comparisons with Tukey adjustment
pairwise_comparisons <- pairs(emm, adjust = "tukey")

# Perform pairwise comparisons with Tukey adjustment
pairwise_ci <- perform_bootstrap_pairwise(NE_AUC_pre_yfp, data ~  LaserLevel + (1|SubjectID), "LaserLevel", "SubjectID", R = 1000)

# Print pairwise comparisons
print(pairwise_comparisons)
print(summary(m_h1_chr2))

#Broken up models
m_h1_yfp <- lmer(formula = data ~  LaserLevel + (1|SubjectID), data = NE_AUC_pre_yfp)
m_h2_yfp <- lmer(formula = data ~  LaserLevel + (LaserLevel|SubjectID), data = NE_AUC_pre_yfp, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))

anova(m_h1_yfp, m_h2_yfp) # m_h1_yfp is better

# Example usage with your model
check_lmm_assumptions(m_h1_yfp)

# Calculate estimated marginal means
emm <- emmeans(m_h1_yfp, ~ LaserLevel, pbkrtest.limit = 3737, lmerTest.limit = 3737)
pairwise_comparisons <- pairs(emm, adjust = "tukey")


# Perform pairwise comparisons with Tukey adjustment
pairwise_ci <- perform_bootstrap_pairwise(NE_AUC_pre_yfp, data ~  LaserLevel + (1|SubjectID), "LaserLevel", "SubjectID", R = 1000)


# Print pairwise comparisons
print(pairwise_ci)
print(pairwise_comparisons)
print(summary(m_h1_yfp))

```

RR AUC vs NE AUC
```{r}
# Combine the columns directly
AUC_prepost <- cbind(NE_AUC_prepost_chr2 %>% select(SubjectID, NE), RR_AUC_prepost_chr2 %>% select(RR))

# Remove duplicate SubjectID column if it exists
AUC_prepost <- AUC_prepost[, !duplicated(colnames(AUC_prepost))]

m_h1 <- lmer(formula = RR ~  NE + (1|SubjectID), data = AUC_prepost)
m_h2 <- lmer(formula = RR ~  NE + (NE|SubjectID), data = AUC_prepost, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
anova(m_h1, m_h2) # M1 better
summary(m_h1)

# Example usage with your model
check_lmm_assumptions(m_h1)

# Transformations
df$RR_log <- log(df$RR + 1)  # Adding 1 to avoid log(0)
df$RR_sqrt <- sqrt(df$RR)
df$RR_inv <- 1 / (df$RR + 1)
# Fit Models with Transformations
m_h1_transformed <- lmer(formula = RR_log ~ Delta + (Delta|SubjectID), data = df)
m_sqrt <- lmer(RR_sqrt ~ Delta + (Delta|SubjectID), data = df)
m_inv <- lmer(RR_inv ~ Delta + (Delta|SubjectID), data = df)

# Check Assumptions for all transformations
check_lmm_assumptions(m_inv)

# Example initialization with a continuous predictor
ci_NE_AUC <- perform_bootstrap_pearson_correlation(AUC_prepost, RR ~  NE + (1|SubjectID), "SubjectID", R = 1000)
ci_NE_AUC <- perform_bootstrap_r2(AUC_prepost, RR ~  NE + (1|SubjectID), "SubjectID", R = 1000)


summary(m_h1)
r.squaredGLMM(m_h1)
print(ci_NE_AUC)
pearson(m_h1, AUC_prepost$RR)
```



```{r}
RR_AUC_prepost_chr2_filtered <- RR_AUC_prepost_chr2 %>%
  filter(is.na(RR_LaserLevel_4) & is.na(RR_LaserLevel_5))

# Filter out rows where NE_LaserLevel_4 or NE_LaserLevel_5 are not NA
NE_AUC_prepost_chr2_filtered <- NE_AUC_prepost_chr2 %>%
  filter(is.na(NE_LaserLevel_4) & is.na(NE_LaserLevel_5))

# Ensure both dataframes have the same length
min_length <- min(nrow(RR_AUC_prepost_chr2_filtered), nrow(NE_AUC_prepost_chr2_filtered))
RR_AUC_prepost_chr2_filtered <- RR_AUC_prepost_chr2_filtered[1:min_length, ]
NE_AUC_prepost_chr2_filtered <- NE_AUC_prepost_chr2_filtered[1:min_length, ]

# Combine the columns directly
AUC_prepost <- cbind(NE_AUC_prepost_chr2_filtered %>% select(SubjectID, NE), 
                     RR_AUC_prepost_chr2_filtered %>% select(RR))

# Remove duplicate SubjectID column if it exists
AUC_prepost <- AUC_prepost[, !duplicated(colnames(AUC_prepost))]

m_h1 <- lmer(formula = RR ~  NE + (1|SubjectID), data = AUC_prepost)
m_h2 <- lmer(formula = RR ~  NE + (NE|SubjectID), data = AUC_prepost, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
anova(m_h1, m_h2) # M1 better
summary(m_h1)

# Example usage with your model
check_lmm_assumptions(m_h1)

# Transformations
# df$RR_log <- log(df$RR + 1)  # Adding 1 to avoid log(0)
# df$RR_sqrt <- sqrt(df$RR)
# df$RR_inv <- 1 / (df$RR + 1)
# # Fit Models with Transformations
# m_h1_transformed <- lmer(formula = RR_log ~ Delta + (Delta|SubjectID), data = df)
# m_sqrt <- lmer(RR_sqrt ~ Delta + (Delta|SubjectID), data = df)
# m_inv <- lmer(RR_inv ~ Delta + (Delta|SubjectID), data = df)
# 
# # Check Assumptions for all transformations
# check_lmm_assumptions(m_inv)

# Example initialization with a continuous predictor
ci_NE_AUC_simple <- perform_bootstrap_pearson_correlation(AUC_prepost, RR ~  NE + (1|SubjectID), "SubjectID", R = 1000)
ci_NE_AUC_simple <- perform_bootstrap_r2(AUC_prepost, RR ~  NE + (1|SubjectID), "SubjectID", R = 1000)

summary(m_h1)
r.squaredGLMM(m_h1)
print(ci_NE_AUC_simple)
pearson(m_h1, AUC_prepost$RR)
```









SUPLEMENTARY
Delta
```{r}

Delta_yfp <- read_csv('C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/AUC recalculated/Delta_yfp_combined_both_table.csv')
Delta_chr2 <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/AUC recalculated/Delta_chr2_combined_both_table.csv")

Delta <- reshape_and_combine(Delta_chr2, Delta_yfp)

m1_Delta_AUC_prepost <- lmer(formula = data ~  LaserLevel * GT + (1|SubjectID), data = Delta, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m2_Delta_AUC_prepost <- lmer(formula = data ~  LaserLevel + GT + (1|SubjectID), data = Delta)

anova(m1_Delta_AUC_prepost, m2_Delta_AUC_prepost) # M1

check_lmm_assumptions(m1_Delta_AUC_prepost) #Normality slightly off


# Calculate estimated marginal means
emm <- emmeans(m1_Delta_AUC_prepost, ~ LaserLevel * GT, pbkrtest.limit = 3737, lmerTest.limit = 3737)


# Perform pairwise comparisons within each GT for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "GT", adjust = "tukey")
# Perform pairwise comparisons between the two levels of GT for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci_Delta_AUC_prepost <- bootstrap_pairwise_contrasts(Delta, data ~ LaserLevel * GT + (1|SubjectID), "LaserLevel * GT", "SubjectID", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci_Delta_AUC_prepost)
print(pairwise_comparisons)
print(summary(m1_Delta_AUC_prepost))

means_data <- aggregate(data ~ LaserLevel + GT, data = Delta, FUN = mean)
print(means_data)
# Create the plot
p <- ggplot(summary_data, aes(x = LaserLevel, y = mean_value, color = GT, group = GT)) +
  geom_point(position = position_dodge(width = 0.2), size = 3) +
  geom_line(position = position_dodge(width = 0.2), size = 1) +
  labs(title = "Mean by Laser Level and GT",
       x = "Laser Level",
       y = "Mean Value",
       color = "GT") +
  theme_minimal()


# Create the plot
p <- ggplot(summary_data, aes(x = LaserLevel, y = mean_value, color = GT, group = GT)) +
  geom_point(position = position_dodge(width = 0.2), size = 3) +
  geom_errorbar(aes(ymin = mean_value - SEM, ymax = mean_value + SEM), 
                width = 0.2, position = position_dodge(width = 0.2)) +
  geom_line(position = position_dodge(width = 0.2), size = 1) +
  labs(title = "Mean and SEM by Laser Level and GT",
       x = "Laser Level",
       y = "Mean Value",
       color = "GT") +
  theme_minimal()

# Print the plot
print(p)
```
Theta

```{r}

Theta_yfp <- read_csv('C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/AUC recalculated/Theta_yfp_combined_both_table.csv')
Theta_chr2 <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/AUC recalculated/Theta_chr2_combined_both_table.csv")

Theta <- reshape_and_combine(Theta_chr2, Theta_yfp)

m1_Theta_AUC_prepost <- lmer(formula = data ~  LaserLevel * GT + (1|SubjectID), data = Theta, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m2_Theta_AUC_prepost <- lmer(formula = data ~  LaserLevel + GT + (1|SubjectID), data = Theta)

anova(m1_Theta_AUC_prepost, m2_Theta_AUC_prepost) # M1

check_lmm_assumptions(m1_Theta_AUC_prepost) #heteroscacedicity


# Calculate estimated marginal means
emm <- emmeans(m1_Theta_AUC_prepost, ~ LaserLevel * GT, pbkrtest.limit = 3737, lmerTest.limit = 3737)


# Perform pairwise comparisons within each GT for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "GT", adjust = "tukey")
# Perform pairwise comparisons between the two levels of GT for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci_Theta_AUC_prepost <- bootstrap_pairwise_contrasts(Theta, data ~ LaserLevel * GT + (1|SubjectID), "LaserLevel * GT", "SubjectID", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci_Theta_AUC_prepost)
print(pairwise_comparisons)
print(summary(m1_Theta_AUC_prepost))
```


Sigma


```{r}

Sigma_yfp <- read_csv('C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/AUC recalculated/Sigma_yfp_combined_both_table.csv')
Sigma_chr2 <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/AUC recalculated/Sigma_chr2_combined_both_table.csv")

Sigma <- reshape_and_combine(Sigma_chr2, Sigma_yfp)

m1_Sigma_AUC_prepost <- lmer(formula = data ~  LaserLevel * GT + (1|SubjectID), data = Sigma, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m2_Sigma_AUC_prepost <- lmer(formula = data ~  LaserLevel + GT + (1|SubjectID), data = Sigma)

anova(m1_Sigma_AUC_prepost, m2_Sigma_AUC_prepost) # M1

check_lmm_assumptions(m1_Sigma_AUC_prepost) #heteroscacedicity


# Calculate estimated marginal means
emm <- emmeans(m1_Sigma_AUC_prepost, ~ LaserLevel * GT, pbkrtest.limit = 3737, lmerTest.limit = 3737)


# Perform pairwise comparisons within each GT for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "GT", adjust = "tukey")
# Perform pairwise comparisons between the two levels of GT for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci_Sigma_AUC_prepost <- bootstrap_pairwise_contrasts(Sigma, data ~ LaserLevel * GT + (1|SubjectID), "LaserLevel * GT", "SubjectID", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci_Sigma_AUC_prepost)
print(pairwise_comparisons)
print(summary(m1_Sigma_AUC_prepost))


```


Beta
SUPLEMENTARY

```{r}

Beta_yfp <- read_csv('C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/AUC recalculated/Beta_yfp_combined_both_table.csv')
Beta_chr2 <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/AUC recalculated/Beta_chr2_combined_both_table.csv")

Beta <- reshape_and_combine(Beta_chr2, Beta_yfp)

m1_Beta_AUC_prepost <- lmer(formula = data ~  LaserLevel * GT + (1|SubjectID), data = Beta, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m2_Beta_AUC_prepost <- lmer(formula = data ~  LaserLevel + GT + (1|SubjectID), data = Beta)

anova(m1_Beta_AUC_prepost, m2_Beta_AUC_prepost) # M1

check_lmm_assumptions(m1_Beta_AUC_prepost) #heteroscacedicity


# Calculate estimated marginal means
emm <- emmeans(m1_Beta_AUC_prepost, ~ LaserLevel * GT, pbkrtest.limit = 3737, lmerTest.limit = 3737)


# Perform pairwise comparisons within each GT for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "GT", adjust = "tukey")
# Perform pairwise comparisons between the two levels of GT for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci_Beta_AUC_prepost <- bootstrap_pairwise_contrasts(Beta, data ~ LaserLevel * GT + (1|SubjectID), "LaserLevel * GT", "SubjectID", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci_Beta_AUC_prepost)
print(pairwise_comparisons)
print(summary(m1_Beta_AUC_prepost))
```

Gamma
SUPLEMENTARY

```{r}

Gamma_high_yfp <- read_csv('C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/AUC recalculated/Gamma_high_yfp_combined_both_table.csv')
Gamma_high_chr2 <- read_csv("C:/Users/trb938/OneDrive - University of Copenhagen/MATLAB/chr2_yfp/yfp data/AUC recalculated/Gamma_high_chr2_combined_both_table.csv")

Gamma_high <- reshape_and_combine(Gamma_high_chr2, Gamma_high_yfp)

m1_Gamma_high_AUC_prepost <- lmer(formula = data ~  LaserLevel * GT + (1|SubjectID), data = Gamma_high, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
m2_Gamma_high_AUC_prepost <- lmer(formula = data ~  LaserLevel + GT + (1|SubjectID), data = Gamma_high)

anova(m1_Gamma_high_AUC_prepost, m2_Gamma_high_AUC_prepost) # M1

check_lmm_assumptions(m1_Gamma_high_AUC_prepost) #slight normality


# Calculate estimated marginal means
emm <- emmeans(m1_Gamma_high_AUC_prepost, ~ LaserLevel * GT, pbkrtest.limit = 3737, lmerTest.limit = 3737)


# Perform pairwise comparisons within each GT for all LaserLevels
contrast_within_GT <- contrast(emm, interaction = "pairwise", by = "GT", adjust = "tukey")
# Perform pairwise comparisons between the two levels of GT for each LaserLevel
contrast_between_GT <- contrast(emm, interaction = "pairwise", by = "LaserLevel", adjust = "tukey")
# Combine the results
pairwise_comparisons <- list(within_GT = contrast_within_GT, between_GT = contrast_between_GT)

pairwise_ci_Gamma_high_AUC_prepost <- bootstrap_pairwise_contrasts(Gamma_high, data ~ LaserLevel * GT + (1|SubjectID), "LaserLevel * GT", "SubjectID", R = 1000)
# print(pairwise_ci)

# Print pairwise comparisons
print(pairwise_ci_Gamma_high_AUC_prepost)
print(pairwise_comparisons)
print(summary(m1_Gamma_high_AUC_prepost))
```

SUPLEMENTARY YFP (ChR2 figure)
RR AUC vs NE AUC
```{r}
# Combine the columns directly
AUC_prepost_yfp <- cbind(NE_AUC_prepost_yfp %>% select(SubjectID, NE), RR_AUC_prepost_yfp %>% select(RR))

# Remove duplicate SubjectID column if it exists
AUC_prepost_yfp <- AUC_prepost_yfp[, !duplicated(colnames(AUC_prepost_yfp))]

m_h1 <- lmer(formula = RR ~  NE + (1|SubjectID), data = AUC_prepost_yfp)
m_h2 <- lmer(formula = RR ~  NE + (NE|SubjectID), data = AUC_prepost_yfp, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
anova(m_h1, m_h2) # M1 better
summary(m_h1)

# Example usage with your model
check_lmm_assumptions(m_h1)

# Example initialization with a continuous predictor
ci_NE_AUC <- perform_bootstrap_pearson_correlation(AUC_prepost_yfp, RR ~  NE + (1|SubjectID), "SubjectID", R = 1000)
ci_NE_AUC <- perform_bootstrap_r2(AUC_prepost_yfp, RR ~  NE + (1|SubjectID), "SubjectID", R = 1000)


summary(m_h1)
r.squaredGLMM(m_h1)
print(ci_NE_AUC)
pearson(m_h1, AUC_prepost_yfp$RR)
```



```{r}
RR_AUC_prepost_yfp_filtered <- RR_AUC_prepost_yfp %>%
  filter(is.na(RR_LaserLevel_4) & is.na(RR_LaserLevel_5))

# Filter out rows where NE_LaserLevel_4 or NE_LaserLevel_5 are not NA
NE_AUC_prepost_yfp_filtered <- NE_AUC_prepost_yfp %>%
  filter(is.na(NE_LaserLevel_4) & is.na(NE_LaserLevel_5))

# Ensure both dataframes have the same length
min_length <- min(nrow(RR_AUC_prepost_yfp_filtered), nrow(NE_AUC_prepost_yfp_filtered))
RR_AUC_prepost_yfp_filtered <- RR_AUC_prepost_yfp_filtered[1:min_length, ]
NE_AUC_prepost_yfp_filtered <- NE_AUC_prepost_yfp_filtered[1:min_length, ]

# Combine the columns directly
AUC_prepost <- cbind(NE_AUC_prepost_yfp_filtered %>% select(SubjectID, NE), 
                     RR_AUC_prepost_yfp_filtered %>% select(RR))

# Remove duplicate SubjectID column if it exists
AUC_prepost <- AUC_prepost[, !duplicated(colnames(AUC_prepost))]

m_h1 <- lmer(formula = RR ~  NE + (1|SubjectID), data = AUC_prepost)
m_h2 <- lmer(formula = RR ~  NE + (NE|SubjectID), data = AUC_prepost, control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)))
anova(m_h1, m_h2) # M1 better
summary(m_h1)

# Example usage with your model
check_lmm_assumptions(m_h1)

# Transformations
# df$RR_log <- log(df$RR + 1)  # Adding 1 to avoid log(0)
# df$RR_sqrt <- sqrt(df$RR)
# df$RR_inv <- 1 / (df$RR + 1)
# # Fit Models with Transformations
# m_h1_transformed <- lmer(formula = RR_log ~ Delta + (Delta|SubjectID), data = df)
# m_sqrt <- lmer(RR_sqrt ~ Delta + (Delta|SubjectID), data = df)
# m_inv <- lmer(RR_inv ~ Delta + (Delta|SubjectID), data = df)
# 
# # Check Assumptions for all transformations
# check_lmm_assumptions(m_inv)

# Example initialization with a continuous predictor
ci_NE_AUC_simple <- perform_bootstrap_pearson_correlation(AUC_prepost, RR ~  NE + (1|SubjectID), "SubjectID", R = 1000)
ci_NE_AUC_simple <- perform_bootstrap_r2(AUC_prepost, RR ~  NE + (1|SubjectID), "SubjectID", R = 1000)

summary(m_h1)
r.squaredGLMM(m_h1)
print(ci_NE_AUC_simple)
pearson(m_h1, AUC_prepost$RR)
```